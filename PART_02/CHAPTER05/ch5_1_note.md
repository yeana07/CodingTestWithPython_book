# CHAPTER05 DFS/BFS

## 1. 꼭 필요한 자료구조 기초

대표적인 탐색 알고리즘인 DFS와 BFS를 이해하려면 기본 자료구조인 스택과 큐에 대한 이해가 필요하다.

**탐색 Search**: 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정

**자료구조 Data Structure**: 데이터를 표현하고 관리하고 처리하기 위한 구조

- 스택
  - FILO, LIFO 구조
  - 입구와 출구가 동일
  - 기본 리스트의 `append()`, `pop()` 이용
- 큐
  - FIFO 구조
  - 대기 줄, 입구와 출구가 모두 뚫려있는 터널
  - 파이썬으로 큐 구현: `colletions` 모듈에서 제공하는 `deque` 자료구조 활용
    - 스택과 큐의 장점 채택

### 재귀 함수

DFS와 BFS를 구현하려면 재귀 함수도 이해하고 있어야 한다.

#### 재귀 함수의 종료 조건

재귀 함수 문제 풀이에서 사용할 때 종료 조건을 꼭 명시해야 한다.

5-4. 재귀 함수 종료 예제

```python
def recursive_function(i):
  # 100번째 호출 시 종료되도록 종료 조건 명시
  if i == 100:
    return
  print(i, '번째 재귀함수에서', i + 1, '번째 재귀함수를 호출합니다.')
  recursive_function(i + 1)
  print(i, '번째 재귀함수를 종료합니다.')

recursive_function(1)
```

재귀 함수의 수행은 컴퓨터 내부에서 스택 자료구조를 이용한다.(연속해서 호출되는 함수는 메인 메모리의 스택 공간에 적재됨) -> 함수 계속 호출 시 가장 마지막 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료되기 때문.

=> **재귀 함수는 내부적으로 스택 자료구조와 동일하다** 기억하기  
=> 스택 자료구조 활용하는 알고리즘은 재귀 함수 이용하면 간편하게 구현 가능(DFS 포함)

5-5. 2가지 방식으로 구현한 팩토리얼 예제

```python
#반복적으로 구현한 n!
def factorial_iterative(n):
  result = 1
  #1부터 n까지의 수를 차례대로 곱하기:
  for i in range(1, n + 1):
    result += 1
  return result

#재귀적으로 구현한 n!
def factorial_recursive(n):
  if n <= 1: #n이 1 이하인 경우 1 반환
    return 1
  #n! = n * (n - 1)!을 그대로 코드로 작성
  return n * factorial_recursive(n - 1)

# 각각의 방식으로 구현한 n! 출력(n = 5)
factorial_iterative(5)
factorial_recursive(5)
```

#### _동영상 강의에 추가된 내용_

#### 최대 공약수(유클리드 호제법) 예제

재귀함수를 이용하는 또 다른 예제.

- 두 개의 자연수에 대한 최대공약수를 구하는 대표적인 알고리즘인 유클리드 호제법이 있습니다.
- **유클리드 호제법**
  - 두 자연수 A, B에 대하여 (A > B) A를 B로 나눈 나머지를 R이라고 합시다.
  - 이때 A와 B의 최대공약수는 B와 R의 최대공약수와 같습니다.
- 유클리드 호제법의 아이디어를 그대로 재귀 함수로 작성할 수 있습니다.
  - 예시: GCD(192, 162) _greatest common devisor_  
    |단계|A|B|
    |:---|:---:|:---:|
    |1|192|162|
    |2|162|30|
    |3|30|12|
    |4|12|6|

_-> 더 작은 수를 이용해 식을 간단히 바꾸는 형태가 반복적이고 동일한 구조여서 재귀 함수를 이용할 수 있다._

유클리드 호제법 코드로 구현하기

```python
def gcd(a, b):
  if a % b == 0: #A가 B의 배수
    return b
  else:
    return gcb(b, a % b)

print(gcd(192,162)

# 실행 결과 => 6
```

#### 재귀 함수 사용 유의 사항

- 재귀 함수를 잘 활용하면 복잡한 알고리즘을 간결하게 작성할 수 있습니다.
  - 단, 오히려 다른 사람이 이해하기 어려운 형태의 코드가 될 수도 있으므로 신중하게 사용해야 합니다.
- 모든 재귀 함수는 반복문을 이용하여 동일한 기능을 구현할 수 있습니다.
- 재귀 함수가 반복문보다 유리한 경우도 있고 불리한 경우도 있습니다.
- 컴퓨터가 함수를 연속적으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓입니다.
  - 그래서 스택을 사용해야 할 때 구현상 **스택 라이브러리 대신에 재귀 함수를 이용**하는 경우가 많습니다.
